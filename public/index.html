<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPS Digital Signage</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="banner">
        <img src="/assets/ops-torch.png" alt="Orono Public Schools Logo">
    </div>

    <div id="slideContainer">
        <div class="loading">Loading presentation...</div>
    </div>

    <script>
        // Quick test to see if JavaScript is running
        console.log('JavaScript is loading...');

        class DigitalSignage {
            constructor() {
                console.log('DigitalSignage constructor called');
                this.config = {
                    deviceId: 'unknown',
                    slideId: null,
                    refreshInterval: 15,
                    template: 'standard',
                    theme: 'default'
                };
                
                // SSE properties
                this.eventSource = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                
                this.init();
            }

            async init() {
                // Get device ID from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                this.config.deviceId = urlParams.get('deviceId') || 'unknown';

                // Load device configuration
                await this.loadDeviceConfig();
                
                // Start SSE connection after configuration is loaded
                if (this.config.deviceId && this.config.deviceId !== 'unknown') {
                    console.log('üîå Starting SSE connection...');
                    this.initializeEventStream();
                } else {
                    console.log('‚ö†Ô∏è  No valid device ID, skipping SSE connection');
                }
            }

            async loadDeviceConfig() {
                try {
                    console.log(`Loading config for device: ${this.config.deviceId}`);

                    const response = await fetch(`/api/device-config/${this.config.deviceId}`);

                    console.log('API Response status:', response.status);

                    if (response.ok) {
                        const config = await response.json();
                        console.log('Configuration loaded:', config);

                        this.config = { ...this.config, ...config };

                        // Apply configuration
                        await this.applyConfiguration();

                        // Set up periodic refresh
                        this.setupRefresh();

                    } else {
                        const errorText = await response.text();
                        console.error('API Error:', errorText);
                        throw new Error(`Failed to load configuration: ${response.status} - ${errorText}`);
                    }
                } catch (error) {
                    console.error('Error loading device configuration:', error);
                    this.showError(`Configuration Error: ${error.message}`);

                    // Try to continue with default configuration after a delay
                    setTimeout(() => {
                        console.log('Attempting to use default configuration...');
                        this.applyDefaultConfiguration();
                    }, 5000);
                }
            }

            async applyConfiguration() {
                try {
                    console.log('Applying configuration:', this.config);
                    
                    // Check for active alerts first
                    const activeAlert = this.getHighestPriorityAlert();

                    if (activeAlert) { // An alert is active
                        console.log(`üö® ALERT ACTIVE: ${activeAlert.name}, Type: ${activeAlert.type || 'slide'}`);
                        this.setAlertUIMode(true);

                        const alertType = activeAlert.type || 'slide'; // Default to slide for old alerts

                        if (alertType === 'slide' && activeAlert.slideId) {
                            this.initializeSlide(activeAlert.slideId);
                        } else if (alertType === 'custom' || alertType === 'srp') {
                            this.renderDynamicAlert(activeAlert);
                        } else {
                            console.warn('Alert is active but misconfigured (unknown type or missing slideId). Displaying error.');
                            this.showError(`Alert "${activeAlert.name}" is not configured correctly.`);
                        }
                    } else {
                        // NO ALERT: Proceed with normal template/slide logic.
                        this.setAlertUIMode(false);

                        // Load custom template if specified. This replaces the body's content
                        // but preserves the running script.
                        if (this.config.template && this.config.template !== 'standard') {
                            await this.loadTemplate(this.config.template);
                        }

                        // --- NEW: Initialize modules after template is loaded ---
                        await this.initializeModules(); 
                        
                        // --- NEW: Initialize the info bar if it exists ---
                        await this.initializeInfoBar();                        

                        // If the template is 'rotation', its own script is responsible for handling content.
                        // For other templates, initialize the slide if an ID is provided.
                        if (this.config.template === 'rotation') {
                            console.log('Rotation template loaded. Its internal script will manage content.');
                            // The rotation template's script is now in control. It will use the
                            // placeholders to construct its own content, including the slideshow.
                        } else if (this.config.slideId) {
                            // For standard, sidebar, etc., templates, we initialize the slide with looping ON.
                            // These templates are expected to provide a #slideContainer element.
                            console.log(`Initializing presentation for slideId: ${this.config.slideId} in template: ${this.config.template}`);
                            this.initializeSlide(this.config.slideId, 'slideContainer', true);
                        } else {
                            console.log('No slideId configured. The template will display its default content.');
                            // For the standard template, not having a slideId is an error.
                            // Custom templates are allowed to function without a slideId.
                            if (!this.config.template || this.config.template === 'standard') {
                                this.showError('No Google Slide ID configured for this device');
                            }
                        }
                    }

                    // Load theme if specified (do this after all template/slide logic)
                    if (this.config.theme && this.config.theme !== 'default') {
                        this.loadTheme(this.config.theme);
                    }

                } catch (error) {
                    console.error('Error applying configuration:', error);
                    this.showError(`Configuration Error: ${error.message}`);
                }
            }

            getHighestPriorityAlert() {
                if (!this.config.alerts || this.config.alerts.length === 0) {
                    console.log('No alerts found in configuration');
                    return null;
                }

                console.log(`Found ${this.config.alerts.length} alerts:`, this.config.alerts);

                // Sort alerts by priority: high > medium > low
                const priorityValues = { high: 3, medium: 2, low: 1 };
                const sortedAlerts = this.config.alerts.sort((a, b) => {
                    // Normalize priorities to lowercase for case-insensitive comparison
                    const priorityA = a.priority ? a.priority.toLowerCase() : 'low';
                    const priorityB = b.priority ? b.priority.toLowerCase() : 'low';
                    
                    return (priorityValues[priorityB] || 1) - (priorityValues[priorityA] || 1);
                });

                const topAlert = sortedAlerts[0];
                console.log('Highest priority alert:', topAlert);
                return topAlert;
            }

            setAlertUIMode(isAlertActive) {
                const header = document.getElementById('banner');
                const body = document.body;

                if (isAlertActive) {
                    console.log('Entering Alert UI Mode (full-screen)');
                    if (header) header.style.display = 'none';
                    body.classList.add('alert-mode');
                } else {
                    console.log('Exiting Alert UI Mode (returning to normal)');
                    if (header) header.style.display = 'block';
                    body.classList.remove('alert-mode');
                }
            }
            
            async initializeModules() {
                const moduleElements = document.querySelectorAll('[data-module]');
                if (moduleElements.length === 0) {
                    console.log('No content modules found in this template.');
                    return;
                }

                console.log(`Found ${moduleElements.length} content modules to initialize.`);
                const promises = [];

                moduleElements.forEach(el => {
                    const moduleType = el.dataset.module;
                    switch (moduleType) {
                        case 'menu':
                            if (this.config.building) {
                                promises.push(this.loadMenuModule(el, this.config.building));
                            }
                            break;
                        case 'calendar':
                            if (this.config.googleCalendarUrl) {
                                promises.push(this.loadCalendarModule(el, this.config.googleCalendarUrl));
                            }
                            break;
                        default:
                            console.warn(`Unknown module type: ${moduleType}`);
                    }
                });

                await Promise.all(promises);
                console.log('All content modules initialized.');
            }

            async loadMenuModule(container, buildingCode) {
                console.log(`Loading menu module for building: ${buildingCode}`);
                container.innerHTML = '<div class="module-loading" style="padding:1em; text-align:center; color: #888;">Loading Menu...</div>';
                try {
                    const response = await fetch(`/api/menu?building=${buildingCode}`);
                    if (response.ok) {
                        const menuHtml = await response.text();
                        container.innerHTML = menuHtml;
                    } else {
                        container.innerHTML = '<div class="module-error" style="padding:1em; text-align:center; color: #aaa;">Menu not available today.</div>';
                    }
                } catch (error) {
                    console.error('Error loading menu module:', error);
                    container.innerHTML = '<div class="module-error" style="padding:1em; text-align:center; color: #f00;">Could not load menu.</div>';
                }
            }

            async loadCalendarModule(container, calendarUrl) {
                console.log('Loading calendar module...');
                container.innerHTML = ''; // Clear any loading message
                try {
                    const url = new URL(calendarUrl);
                    url.searchParams.set('cacheBust', Date.now());
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = url.toString();
                    iframe.style.cssText = 'width:100%; height:100%; border:0;';
                    iframe.setAttribute('frameborder', '0');
                    iframe.setAttribute('scrolling', 'no');
                    
                    container.appendChild(iframe);
                } catch (error) {
                    console.error('Error loading calendar module (invalid URL?):', error);
                    container.innerHTML = '<div class="module-error" style="padding:1em; text-align:center; color: #f00;">Invalid Calendar URL.</div>';
                }
            }

            async initializeInfoBar() {
                const infoBar = document.getElementById('info-bar');
                if (!infoBar) return;

                console.log('Initializing info bar...');

                const dateEl = document.getElementById('info-date');
                const timeEl = document.getElementById('info-time');
                const weatherEl = document.getElementById('info-weather');

                // Function to update date and time
                const updateDateTime = () => {
                    const now = new Date();
                    if (dateEl) {
                        dateEl.textContent = now.toLocaleDateString('en-US', {
                            weekday: 'long',
                            month: 'long',
                            day: 'numeric'
                        });
                    }
                    if (timeEl) {
                        timeEl.textContent = now.toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit'
                        }).replace(' ', ''); // Remove space before AM/PM
                    }
                };

                updateDateTime(); // Initial call
                setInterval(updateDateTime, 1000 * 30); // Update every 30 seconds is sufficient

                // Load weather if configured
                if (weatherEl && this.config.coordinates) {
                    this.loadWeatherModule(weatherEl, this.config.coordinates);
                    // Refresh weather every 15 minutes
                    setInterval(() => this.loadWeatherModule(weatherEl, this.config.coordinates), 15 * 60 * 1000);
                }
            }

            async loadWeatherModule(container, coordinates) {
                try {
                    const response = await fetch(`/api/weather?coords=${coordinates}`);
                    if (response.ok) {
                        const weather = await response.json();
                        container.innerHTML = `<img src="${weather.icon.replace(',0',',1')}" alt="${weather.description}" class="weather-icon"><span class="weather-temp">${weather.temperature}¬∞</span>`;
                    }
                } catch (error) {
                    console.error('Error loading weather module:', error);
                }
            }            

            // ==================== SSE IMPLEMENTATION ====================

            initializeEventStream() {
                if (!this.config.deviceId || this.config.deviceId === 'unknown') {
                    console.log('‚ùå Cannot establish SSE: Invalid device ID');
                    return;
                }

                const eventSourceUrl = `/api/device/${this.config.deviceId}/events`;
                console.log(`üîå Connecting to SSE: ${eventSourceUrl}`);
                
                // Clean up existing connection if any
                if (this.eventSource) {
                    this.eventSource.close();
                }
                
                this.eventSource = new EventSource(eventSourceUrl);
                
                this.eventSource.onopen = (event) => {
                    console.log('‚úÖ SSE connection established successfully');
                    this.reconnectAttempts = 0;
                    this.reconnectDelay = 1000; // Reset delay
                    
                    // Show connection status in UI
                    this.showConnectionStatus('SSE Connected', 'success');
                };
                
                this.eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì® Received server update:', data);
                        this.handleServerUpdate(data);
                    } catch (err) {
                        console.error('‚ùå Failed to parse SSE message:', err);
                    }
                };
                
                this.eventSource.onerror = (error) => {
                    console.log('‚ùå SSE connection error:', error);
                    this.showConnectionStatus('SSE Disconnected', 'error');
                    this.handleSSEReconnect();
                };
            }

            handleServerUpdate(data) {
                console.log(`üì® Processing update type: ${data.type}`);
                
                switch (data.type) {
                    case 'connected':
                        console.log('‚úÖ SSE connection confirmed by server');
                        break;
                        
                    case 'refresh':
                        console.log('üîÑ Server requested configuration refresh');
                        this.handleRefreshCommand(data);
                        break;
                        
                    case 'alert':
                        console.log('üö® Alert update received');
                        this.handleAlertUpdate(data);
                        break;
                        
                    case 'config_update':
                        console.log('‚öôÔ∏è Configuration update received');
                        this.handleConfigUpdate(data);
                        break;
                        
                    case 'template_change':
                        console.log('üé® Template change requested');
                        this.handleTemplateChange(data);
                        break;
                        
                    case 'test':
                        console.log('üß™ Test message received:', data.message);
                        this.showNotification(`Test: ${data.message}`, 'info');
                        break;
                        
                    default:
                        console.log('‚ùì Unknown update type:', data.type, data);
                }
            }

            handleRefreshCommand(data) {
                console.log('üîÑ Executing server-requested refresh...');
                
                // Show notification that refresh was triggered by server
                this.showNotification('Refreshing content (server request)', 'info');
                
                // Reload configuration instead of full page refresh for better UX
                this.loadDeviceConfig();
            }

            handleAlertUpdate(data) {
                console.log('üö® Processing alert update:', data);
                
                // Force refresh to get latest alert configuration
                this.showNotification('Alert update received', 'warning');
                this.loadDeviceConfig();
            }

            handleConfigUpdate(data) {
                console.log('‚öôÔ∏è Applying configuration update:', data);
                
                let needsRefresh = false;
                
                // Update slide ID if changed
                if (data.slideId && data.slideId !== this.config.slideId) {
                    console.log(`üìä Updating slide ID: ${this.config.slideId} ‚Üí ${data.slideId}`);
                    this.config.slideId = data.slideId;
                    this.initializeSlide(data.slideId);
                    needsRefresh = true;
                }
                
                // Update template if changed
                if (data.template && data.template !== this.config.template) {
                    console.log(`üé® Updating template: ${this.config.template} ‚Üí ${data.template}`);
                    this.config.template = data.template;
                    this.loadTemplate(data.template);
                    needsRefresh = true;
                }
                
                if (needsRefresh) {
                    this.showNotification('Configuration updated', 'success');
                }
            }

            handleTemplateChange(data) {
                if (data.template && data.template !== this.config.template) {
                    console.log(`üé® Changing template: ${this.config.template} ‚Üí ${data.template}`);
                    this.config.template = data.template;
                    this.showNotification(`Switching to ${data.template} template`, 'info');
                    this.loadTemplate(data.template);
                }
            }

            handleSSEReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    
                    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
                    this.reconnectDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);
                    
                    console.log(`üîÑ Attempting SSE reconnection in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`);
                    
                    setTimeout(() => {
                        if (this.eventSource) {
                            this.eventSource.close();
                        }
                        this.initializeEventStream();
                    }, this.reconnectDelay);
                } else {
                    console.log('‚ùå Max SSE reconnection attempts reached, giving up');
                    this.showConnectionStatus('SSE Failed', 'error');
                    
                    // Fall back to regular polling interval as backup
                    console.log('üîÑ Falling back to regular refresh interval');
                }
            }

            showConnectionStatus(status, type) {
                // Create or update connection status indicator
                let statusElement = document.getElementById('connection-status');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'connection-status';
                    statusElement.style.cssText = `
                        position: fixed;
                        top: 10px;
                        right: 10px;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: bold;
                        z-index: 10000;
                        transition: all 0.3s ease;
                    `;
                    document.body.appendChild(statusElement);
                }
                
                // Style based on connection type
                const colors = {
                    success: { bg: '#4CAF50', text: 'white' },
                    error: { bg: '#f44336', text: 'white' },
                    warning: { bg: '#ff9800', text: 'white' },
                    info: { bg: '#2196F3', text: 'white' }
                };
                
                const color = colors[type] || colors.info;
                statusElement.style.backgroundColor = color.bg;
                statusElement.style.color = color.text;
                statusElement.textContent = status;
                
                // Auto-hide success messages after 3 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        if (statusElement && statusElement.textContent === status) {
                            statusElement.style.opacity = '0';
                            setTimeout(() => {
                                if (statusElement && statusElement.style.opacity === '0') {
                                    statusElement.remove();
                                }
                            }, 300);
                        }
                    }, 3000);
                }
            }

            showNotification(message, type = 'info') {
                console.log(`üîî Notification: ${message}`);
                
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50px;
                    right: 10px;
                    padding: 12px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                    max-width: 300px;
                    z-index: 10001;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                `;
                
                // Style based on type
                const colors = {
                    success: { bg: '#4CAF50', text: 'white' },
                    error: { bg: '#f44336', text: 'white' },
                    warning: { bg: '#ff9800', text: 'white' },
                    info: { bg: '#2196F3', text: 'white' }
                };
                
                const color = colors[type] || colors.info;
                notification.style.backgroundColor = color.bg;
                notification.style.color = color.text;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }

            cleanup() {
                if (this.eventSource) {
                    console.log('üßπ Cleaning up SSE connection');
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            // ==================== END SSE IMPLEMENTATION ====================

            renderDynamicAlert(alert) {
                const slideContainer = document.getElementById('slideContainer');
                if (!slideContainer) {
                    console.error('Slide container not found for dynamic alert');
                    return;
                }

                let title = '';
                let bodyHtml = '';
                let iconHtml = '';
                let containerClass = 'dynamic-alert-container';

                // Data for different alert types
                const srpInfo = {
                    'Hold': { title: 'HOLD', subtitle: 'In Your Room or Area', cssClass: 'srp-hold', icon: 'srp-hold.png' },
                    'Secure': { title: 'SECURE', subtitle: 'Get Inside. Lock Outside Doors.', cssClass: 'srp-secure', icon: 'srp-secure.png' },
                    'Lockdown': { title: 'LOCKDOWN', subtitle: 'Locks, Lights, Out of Sight', cssClass: 'srp-lockdown', icon: 'srp-lockdown.png' },
                    'Evacuate': { title: 'EVACUATE', subtitle: 'To a Location', cssClass: 'srp-evacuate', icon: 'srp-evacuate.png' },
                    'Shelter': { title: 'SHELTER', subtitle: 'For a Hazard', cssClass: 'srp-shelter', icon: 'srp-shelter.png' }
                };

                const customIcons = {
                    'exclamation-triangle': '‚ö†Ô∏è',
                    'info-circle': '‚ÑπÔ∏è',
                    'check-circle': '‚úÖ',
                    'times-circle': '‚ùå'
                };

                if (alert.type === 'srp' && srpInfo[alert.srpAction]) {
                    const srp = srpInfo[alert.srpAction];
                    containerClass += ` ${srp.cssClass}`;
                    title = srp.title;
                    bodyHtml = `<h2>${srp.subtitle}</h2>`;
                    if (alert.text) {
                        bodyHtml += `<p class="srp-instructions">${alert.text}</p>`;
                    }
                    if (srp.icon) {
                        iconHtml = `<img src="/assets/srp/${srp.icon}" alt="${srp.title} Icon" class="srp-image-icon">`;
                    }
                } else { // 'custom' or fallback
                    containerClass += ' custom-alert';
                    title = alert.title || 'Alert';
                    bodyHtml = `<p>${alert.text || ''}</p>`;
                    if (alert.icon && customIcons[alert.icon]) {
                        iconHtml = `<div class="custom-icon">${customIcons[alert.icon]}</div>`;
                    }
                }

                slideContainer.innerHTML = `
                    <div class="${containerClass}">${iconHtml}<div class="alert-content"><h1>${title}</h1><div class="alert-body">${bodyHtml}</div></div></div>
                `;
            }

            async loadTemplate(templateName) {
                try {
                    // Fetch the template HTML content.
                    const response = await fetch(`/templates/${templateName}/index.html.template`);

                    if (response.ok) {
                        let templateText = await response.text();

                        // --- Dynamic duration calculation for rotation template (in MILLISECONDS) ---
                        // The template's script expects values for setTimeout, which uses milliseconds.
                        // Use a shorter, more sensible fallback of 120 seconds (2 minutes) instead of 600 (10 minutes).
                        // This prevents a long "hang" if the slide count API fails.
                        let presentationDurationMs = (this.config.presentationDuration || 120) * 1000;
                        let itemDurationMs = (this.config.rotationItemDuration || 15) * 1000;
                    
                        if (templateName === 'rotation' && this.config.slideId) {
                            try {
                                console.log('Rotation template: Fetching dynamic slide count...');
                                const slideInfoResponse = await fetch(`/api/slide-info/${this.config.slideId}`);
                                if (slideInfoResponse.ok) {
                                    const slideInfo = await slideInfoResponse.json();
                                    const slideCount = slideInfo.activeSlides || 0;
                                    if (slideCount > 0) {
                                        // Assuming 10 seconds per slide, convert to milliseconds.
                                        const calculatedDurationMs = slideCount * 10 * 1000;
                                        console.log(`Calculated presentation duration: ${slideCount} active slides * 10s = ${calculatedDurationMs / 1000}s`);
                                        presentationDurationMs = calculatedDurationMs;
                                    } else {
                                        console.warn('Slide count was 0, using configured fallback duration of 120s.');
                                    }
                                } else {
                                    console.warn('Failed to fetch slide count, using configured fallback duration of 120s.');
                                }
                            } catch (err) {
                                console.error('Error fetching slide count, using configured fallback duration of 120s.', err);
                            }
                        }

                        // The rotation template should not loop its slideshow, but others might.
                        const loopSlides = (templateName !== 'rotation');                        

                        // Replace placeholders in the fetched template HTML.
                        templateText = templateText
                            .replace(/{LOCATION}/g, this.config.location || 'Orono Public Schools')
                            .replace(/{BUILDING_NAME}/g, this.config.buildingName || '')                            
                            .replace(/{PRESENTATION_ID}/g, this.config.slideId || '')
                            .replace(/{DEVICE_ID}/g, this.config.deviceId)
                            .replace(/{THEME_PATH}/g, `/themes/${this.config.theme || 'default'}.css`)
                            .replace(/{SLIDESHOW_LOOP_PARAM}/g, loopSlides ? 'true' : 'false')
                            // Add rotation-specific placeholders. Pass values in milliseconds.
                            .replace(/{PRESENTATION_DURATION}/g, presentationDurationMs.toString())
                            .replace(/{ROTATION_ITEM_DURATION}/g, itemDurationMs.toString())
                            .replace(/{GOOGLE_CALENDAR_URL}/g, this.config.googleCalendarUrl || '')
                            .replace(/{BUILDING_CODE}/g, this.config.building || '');

                        const parser = new DOMParser();
                        const templateDoc = parser.parseFromString(templateText, 'text/html');

                        // Grab the currently running script so we can preserve it.
                        const mainScript = document.querySelector('body > script:last-of-type');

                        // Clear the current body.
                        document.body.innerHTML = '';

                        // NEW: Process and append styles from the template's <head>.
                        // This ensures that styles defined within the template are applied.
                        Array.from(templateDoc.head.childNodes).forEach(node => {
                            if (node.nodeName.toLowerCase() === 'style' || (node.nodeName.toLowerCase() === 'link' && node.rel === 'stylesheet')) {
                                document.head.appendChild(node.cloneNode(true));
                            }
                        });

                        // Separate the template's body nodes from its scripts.
                        // Scripts inserted this way don't execute, so they need special handling.
                        const templateBodyNodes = Array.from(templateDoc.body.childNodes);
                        const scriptsToExecute = [];

                        templateBodyNodes.forEach(node => {
                            if (node.nodeName.toLowerCase() === 'script') {
                                scriptsToExecute.push(node);
                            } else {
                                document.body.appendChild(node.cloneNode(true));
                            }
                        });                        

                        // Re-append the main script to the new body.
                        if (mainScript) document.body.appendChild(mainScript);

                        // Now, create and append new script elements to force execution.
                        scriptsToExecute.forEach(scriptNode => {
                            const newScript = document.createElement('script');
                            newScript.textContent = scriptNode.textContent;
                            document.body.appendChild(newScript);
                        });

                        console.log(`Template "${templateName}" loaded successfully`);
                    } else {
                        throw new Error(`Template "${templateName}" not found`);
                    }
                } catch (error) {
                    console.error('Error loading template:', error);
                    // Show a non-blocking notification that the template failed to load
                    this.showNotification(`Failed to load template '${templateName}'. Falling back to standard view.`, 'error');

                    // Grab the currently running script so we can preserve it.
                    const mainScript = document.querySelector('body > script:last-of-type');

                    // The logic in applyConfiguration will now handle showing the standard slide,
                    // so we just need to ensure the #slideContainer exists for it to populate.
                    // Restore the standard body structure.
                    document.body.innerHTML = '<div id="banner"><img src="/assets/ops-torch.png" alt="Orono Public Schools Logo"></div><div id="slideContainer"><div class="loading">Loading presentation...</div></div>';
                    
                    // Re-append the main script to the new body.
                    if (mainScript) document.body.appendChild(mainScript);
                 }
            }

            loadTheme(themeName) {
                // Remove any existing custom theme
                const existingTheme = document.getElementById('custom-theme');
                if (existingTheme) {
                    existingTheme.remove();
                }

                // Add new theme
                const link = document.createElement('link');
                link.id = 'custom-theme';
                link.rel = 'stylesheet';
                link.href = `/themes/${themeName}.css`;
                link.onerror = () => {
                    console.warn(`Theme "${themeName}" not found, using default`);
                };
                document.head.appendChild(link);
            }

            initializeSlide(slideId, containerId = 'slideContainer', loop = true) {
                const slideContainer = document.getElementById(containerId);
                // Only initialize if the container exists and doesn't already have an iframe.
                if (slideContainer && !slideContainer.querySelector('iframe')) {
                    const loopParam = loop ? 'true' : 'false';
                    slideContainer.innerHTML = `
                        <iframe
                            src="https://docs.google.com/presentation/d/${slideId}/embed?start=true&loop=${loopParam}&delayms=10000&rm=minimal"
                            frameborder="0"
                            width="100%"
                            height="100%"
                            allowfullscreen="true">
                        </iframe>
                    `;
                    console.log(`Google Slide initialized in #${containerId} with loop=${loopParam}: ${slideId}`);
                } else {
                    console.error(`Slide container #${containerId} not found`);
                }
            }

            applyDefaultConfiguration() {
                console.log('Applying default configuration');
                this.config.slideId = '1E7v2rVGN8TabxalUlXSHE2zEhJxv0tEXiCxE3FD99Ic';
                this.initializeSlide(this.config.slideId);
            }

            setupRefresh() {
                const refreshMinutes = this.config.refreshInterval || 15;

                console.log(`Setting up refresh every ${refreshMinutes} minutes`);

                setTimeout(() => {
                    console.log('Refreshing page...');
                    window.location.reload();
                }, refreshMinutes * 60 * 1000);
            }

            showError(message) {
                const slideContainer = document.getElementById('slideContainer');
                if (slideContainer) {
                    slideContainer.innerHTML = `
                        <div class="error-message">
                            <h2>‚ö†Ô∏è Display Error</h2>
                            <p>${message}</p>
                            <p class="retry-message">Retrying in 30 seconds...</p>
                        </div>
                    `;
                }

                // Retry after 30 seconds
                setTimeout(() => {
                    this.loadDeviceConfig();
                }, 30000);
            }
        }

        // Initialize digital signage when page loads
        console.log('DOM loaded, creating DigitalSignage instance...');
        let digitalSignageInstance = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded event fired');
            digitalSignageInstance = new DigitalSignage();
            
            // Store reference globally for cleanup
            window.opsignDisplay = digitalSignageInstance;
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (digitalSignageInstance) {
                digitalSignageInstance.cleanup();
            }
        });
    </script>
</body>
</html>
