<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPS Digital Signage</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="banner">
        <img src="/assets/ops-torch.png" alt="Orono Public Schools Logo">
    </div>

    <div id="slideContainer">
        <div class="loading">Loading presentation...</div>
    </div>

    <script>
        // Quick test to see if JavaScript is running
        console.log('JavaScript is loading...');

        class DigitalSignage {
            constructor() {
                console.log('DigitalSignage constructor called');
                this.config = {
                    deviceId: 'unknown',
                    slideId: null,
                    refreshInterval: 15,
                    template: 'standard',
                    theme: 'default'
                };
                
                // SSE properties
                this.eventSource = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                
                this.init();
            }

            async init() {
                // Get device ID from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                this.config.deviceId = urlParams.get('deviceId') || 'unknown';

                // Load device configuration
                await this.loadDeviceConfig();
                
                // Start SSE connection after configuration is loaded
                if (this.config.deviceId && this.config.deviceId !== 'unknown') {
                    console.log('üîå Starting SSE connection...');
                    this.initializeEventStream();
                } else {
                    console.log('‚ö†Ô∏è  No valid device ID, skipping SSE connection');
                }
            }

            async loadDeviceConfig() {
                try {
                    console.log(`Loading config for device: ${this.config.deviceId}`);

                    const response = await fetch(`/api/device-config/${this.config.deviceId}`);

                    console.log('API Response status:', response.status);

                    if (response.ok) {
                        const config = await response.json();
                        console.log('Configuration loaded:', config);

                        this.config = { ...this.config, ...config };

                        // Apply configuration
                        await this.applyConfiguration();

                        // Set up periodic refresh
                        this.setupRefresh();

                    } else {
                        const errorText = await response.text();
                        console.error('API Error:', errorText);
                        throw new Error(`Failed to load configuration: ${response.status} - ${errorText}`);
                    }
                } catch (error) {
                    console.error('Error loading device configuration:', error);
                    this.showError(`Configuration Error: ${error.message}`);

                    // Try to continue with default configuration after a delay
                    setTimeout(() => {
                        console.log('Attempting to use default configuration...');
                        this.applyDefaultConfiguration();
                    }, 5000);
                }
            }

            async applyConfiguration() {
                try {
                    console.log('Applying configuration:', this.config);
                    
                    // Check for active alerts first
                    const activeAlert = this.getHighestPriorityAlert();

                    if (activeAlert) { // An alert is active, switch to full-screen alert mode
                        console.log(`üö® ALERT ACTIVE: ${activeAlert.name}. Switching to full-screen alert view.`);
                        // Alerts override any custom template.
                        this.setAlertUIMode(true);
                        this.initializeSlide(activeAlert.slideId);
                    } else {
                        // NO ALERT: Proceed with normal template/slide logic.
                        this.setAlertUIMode(false);

                        // Load custom template if specified. This replaces the body's content
                        // but preserves the running script.
                        if (this.config.template && this.config.template !== 'standard') {
                            await this.loadTemplate(this.config.template);
                        }

                        // After the template is loaded (or if using the standard one),
                        // initialize the Google Slide if an ID is configured.
                        // This allows custom templates to either use their own content
                        // or act as a container for a standard presentation.
                        if (this.config.slideId) {
                            console.log(`Initializing presentation for slideId: ${this.config.slideId}`);
                            this.initializeSlide(this.config.slideId);
                        } else {
                            console.log('No slideId configured. The template will display its default content.');
                            // For the standard template, not having a slideId is an error.
                            // Custom templates are allowed to function without a slideId.
                            if (!this.config.template || this.config.template === 'standard') {
                                this.showError('No Google Slide ID configured for this device');
                            }
                        }
                    }

                    // Load theme if specified (do this after all template/slide logic)
                    if (this.config.theme && this.config.theme !== 'default') {
                        this.loadTheme(this.config.theme);
                    }

                } catch (error) {
                    console.error('Error applying configuration:', error);
                    this.showError(`Configuration Error: ${error.message}`);
                }
            }

            getHighestPriorityAlert() {
                if (!this.config.alerts || this.config.alerts.length === 0) {
                    console.log('No alerts found in configuration');
                    return null;
                }

                console.log(`Found ${this.config.alerts.length} alerts:`, this.config.alerts);

                // Sort alerts by priority: high > medium > low
                const priorityValues = { high: 3, medium: 2, low: 1 };
                const sortedAlerts = this.config.alerts.sort((a, b) => {
                    // Normalize priorities to lowercase for case-insensitive comparison
                    const priorityA = a.priority ? a.priority.toLowerCase() : 'low';
                    const priorityB = b.priority ? b.priority.toLowerCase() : 'low';
                    
                    return (priorityValues[priorityB] || 1) - (priorityValues[priorityA] || 1);
                });

                const topAlert = sortedAlerts[0];
                console.log('Highest priority alert:', topAlert);
                return topAlert;
            }

            setAlertUIMode(isAlertActive) {
                const header = document.getElementById('banner');
                const body = document.body;

                if (isAlertActive) {
                    console.log('Entering Alert UI Mode (full-screen)');
                    if (header) header.style.display = 'none';
                    body.classList.add('alert-mode');
                } else {
                    console.log('Exiting Alert UI Mode (returning to normal)');
                    if (header) header.style.display = 'block';
                    body.classList.remove('alert-mode');
                }
            }
            
            // ==================== SSE IMPLEMENTATION ====================

            initializeEventStream() {
                if (!this.config.deviceId || this.config.deviceId === 'unknown') {
                    console.log('‚ùå Cannot establish SSE: Invalid device ID');
                    return;
                }

                const eventSourceUrl = `/api/device/${this.config.deviceId}/events`;
                console.log(`üîå Connecting to SSE: ${eventSourceUrl}`);
                
                // Clean up existing connection if any
                if (this.eventSource) {
                    this.eventSource.close();
                }
                
                this.eventSource = new EventSource(eventSourceUrl);
                
                this.eventSource.onopen = (event) => {
                    console.log('‚úÖ SSE connection established successfully');
                    this.reconnectAttempts = 0;
                    this.reconnectDelay = 1000; // Reset delay
                    
                    // Show connection status in UI
                    this.showConnectionStatus('SSE Connected', 'success');
                };
                
                this.eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì® Received server update:', data);
                        this.handleServerUpdate(data);
                    } catch (err) {
                        console.error('‚ùå Failed to parse SSE message:', err);
                    }
                };
                
                this.eventSource.onerror = (error) => {
                    console.log('‚ùå SSE connection error:', error);
                    this.showConnectionStatus('SSE Disconnected', 'error');
                    this.handleSSEReconnect();
                };
            }

            handleServerUpdate(data) {
                console.log(`üì® Processing update type: ${data.type}`);
                
                switch (data.type) {
                    case 'connected':
                        console.log('‚úÖ SSE connection confirmed by server');
                        break;
                        
                    case 'refresh':
                        console.log('üîÑ Server requested configuration refresh');
                        this.handleRefreshCommand(data);
                        break;
                        
                    case 'alert':
                        console.log('üö® Alert update received');
                        this.handleAlertUpdate(data);
                        break;
                        
                    case 'config_update':
                        console.log('‚öôÔ∏è Configuration update received');
                        this.handleConfigUpdate(data);
                        break;
                        
                    case 'template_change':
                        console.log('üé® Template change requested');
                        this.handleTemplateChange(data);
                        break;
                        
                    case 'test':
                        console.log('üß™ Test message received:', data.message);
                        this.showNotification(`Test: ${data.message}`, 'info');
                        break;
                        
                    default:
                        console.log('‚ùì Unknown update type:', data.type, data);
                }
            }

            handleRefreshCommand(data) {
                console.log('üîÑ Executing server-requested refresh...');
                
                // Show notification that refresh was triggered by server
                this.showNotification('Refreshing content (server request)', 'info');
                
                // Reload configuration instead of full page refresh for better UX
                this.loadDeviceConfig();
            }

            handleAlertUpdate(data) {
                console.log('üö® Processing alert update:', data);
                
                // Force refresh to get latest alert configuration
                this.showNotification('Alert update received', 'warning');
                this.loadDeviceConfig();
            }

            handleConfigUpdate(data) {
                console.log('‚öôÔ∏è Applying configuration update:', data);
                
                let needsRefresh = false;
                
                // Update slide ID if changed
                if (data.slideId && data.slideId !== this.config.slideId) {
                    console.log(`üìä Updating slide ID: ${this.config.slideId} ‚Üí ${data.slideId}`);
                    this.config.slideId = data.slideId;
                    this.initializeSlide(data.slideId);
                    needsRefresh = true;
                }
                
                // Update template if changed
                if (data.template && data.template !== this.config.template) {
                    console.log(`üé® Updating template: ${this.config.template} ‚Üí ${data.template}`);
                    this.config.template = data.template;
                    this.loadTemplate(data.template);
                    needsRefresh = true;
                }
                
                if (needsRefresh) {
                    this.showNotification('Configuration updated', 'success');
                }
            }

            handleTemplateChange(data) {
                if (data.template && data.template !== this.config.template) {
                    console.log(`üé® Changing template: ${this.config.template} ‚Üí ${data.template}`);
                    this.config.template = data.template;
                    this.showNotification(`Switching to ${data.template} template`, 'info');
                    this.loadTemplate(data.template);
                }
            }

            handleSSEReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    
                    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
                    this.reconnectDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);
                    
                    console.log(`üîÑ Attempting SSE reconnection in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`);
                    
                    setTimeout(() => {
                        if (this.eventSource) {
                            this.eventSource.close();
                        }
                        this.initializeEventStream();
                    }, this.reconnectDelay);
                } else {
                    console.log('‚ùå Max SSE reconnection attempts reached, giving up');
                    this.showConnectionStatus('SSE Failed', 'error');
                    
                    // Fall back to regular polling interval as backup
                    console.log('üîÑ Falling back to regular refresh interval');
                }
            }

            showConnectionStatus(status, type) {
                // Create or update connection status indicator
                let statusElement = document.getElementById('connection-status');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'connection-status';
                    statusElement.style.cssText = `
                        position: fixed;
                        top: 10px;
                        right: 10px;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: bold;
                        z-index: 10000;
                        transition: all 0.3s ease;
                    `;
                    document.body.appendChild(statusElement);
                }
                
                // Style based on connection type
                const colors = {
                    success: { bg: '#4CAF50', text: 'white' },
                    error: { bg: '#f44336', text: 'white' },
                    warning: { bg: '#ff9800', text: 'white' },
                    info: { bg: '#2196F3', text: 'white' }
                };
                
                const color = colors[type] || colors.info;
                statusElement.style.backgroundColor = color.bg;
                statusElement.style.color = color.text;
                statusElement.textContent = status;
                
                // Auto-hide success messages after 3 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        if (statusElement && statusElement.textContent === status) {
                            statusElement.style.opacity = '0';
                            setTimeout(() => {
                                if (statusElement && statusElement.style.opacity === '0') {
                                    statusElement.remove();
                                }
                            }, 300);
                        }
                    }, 3000);
                }
            }

            showNotification(message, type = 'info') {
                console.log(`üîî Notification: ${message}`);
                
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50px;
                    right: 10px;
                    padding: 12px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                    max-width: 300px;
                    z-index: 10001;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                `;
                
                // Style based on type
                const colors = {
                    success: { bg: '#4CAF50', text: 'white' },
                    error: { bg: '#f44336', text: 'white' },
                    warning: { bg: '#ff9800', text: 'white' },
                    info: { bg: '#2196F3', text: 'white' }
                };
                
                const color = colors[type] || colors.info;
                notification.style.backgroundColor = color.bg;
                notification.style.color = color.text;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }

            cleanup() {
                if (this.eventSource) {
                    console.log('üßπ Cleaning up SSE connection');
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            // ==================== END SSE IMPLEMENTATION ====================

            async loadTemplate(templateName) {
                try {
                    // Fetch the template HTML content.
                    const response = await fetch(`/templates/${templateName}/index.html.template`);

                    if (response.ok) {
                        let templateText = await response.text();

                        // Replace placeholders in the fetched template HTML.
                        templateText = templateText
                            .replace(/{LOCATION}/g, this.config.location || 'Orono Public Schools')
                            .replace(/{PRESENTATION_ID}/g, this.config.slideId || '')
                            .replace(/{DEVICE_ID}/g, this.config.deviceId)
                            .replace(/{THEME_PATH}/g, `/themes/${this.config.theme || 'default'}.css`);

                        // CRITICAL FIX: The original implementation was flawed and destroyed the running script.
                        // This new implementation parses the template and replaces the content of the
                        // body safely, preserving the running script.
                        const parser = new DOMParser();
                        const templateDoc = parser.parseFromString(templateText, 'text/html');
                        const templateBody = templateDoc.body;

                        // Grab the currently running script so we can preserve it.
                        const mainScript = document.querySelector('body > script:last-of-type');

                        // Clear the current body.
                        document.body.innerHTML = '';

                        // Append the content from the template's body.
                        while (templateBody.firstChild) {
                            document.body.appendChild(templateBody.firstChild);
                        }

                        // Re-append the main script to the new body.
                        if (mainScript) document.body.appendChild(mainScript);

                        console.log(`Template "${templateName}" loaded successfully`);
                    } else {
                        throw new Error(`Template "${templateName}" not found`);
                    }
                } catch (error) {
                    console.error('Error loading template:', error);
                    // Show a non-blocking notification that the template failed to load
                    this.showNotification(`Failed to load template '${templateName}'. Falling back to standard view.`, 'error');

                    // Grab the currently running script so we can preserve it.
                    const mainScript = document.querySelector('body > script:last-of-type');

                    // The logic in applyConfiguration will now handle showing the standard slide,
                    // so we just need to ensure the #slideContainer exists for it to populate.
                    // Restore the standard body structure.
                    document.body.innerHTML = '<div id="banner"><img src="/assets/ops-torch.png" alt="Orono Public Schools Logo"></div><div id="slideContainer"><div class="loading">Loading presentation...</div></div>';
                    
                    // Re-append the main script to the new body.
                    if (mainScript) document.body.appendChild(mainScript);
                 }
            }

            loadTheme(themeName) {
                // Remove any existing custom theme
                const existingTheme = document.getElementById('custom-theme');
                if (existingTheme) {
                    existingTheme.remove();
                }

                // Add new theme
                const link = document.createElement('link');
                link.id = 'custom-theme';
                link.rel = 'stylesheet';
                link.href = `/themes/${themeName}.css`;
                link.onerror = () => {
                    console.warn(`Theme "${themeName}" not found, using default`);
                };
                document.head.appendChild(link);
            }

            initializeSlide(slideId) {
                const slideContainer = document.getElementById('slideContainer');
                if (slideContainer) {
                    slideContainer.innerHTML = `
                        <iframe
                            src="https://docs.google.com/presentation/d/${slideId}/embed?start=true&loop=true&delayms=10000&rm=minimal"
                            frameborder="0"
                            width="100%"
                            height="100%"
                            allowfullscreen="true">
                        </iframe>
                    `;
                    console.log(`Google Slide initialized: ${slideId}`);
                } else {
                    console.error('Slide container not found');
                }
            }

            applyDefaultConfiguration() {
                console.log('Applying default configuration');
                this.config.slideId = '1E7v2rVGN8TabxalUlXSHE2zEhJxv0tEXiCxE3FD99Ic';
                this.initializeSlide(this.config.slideId);
            }

            setupRefresh() {
                const refreshMinutes = this.config.refreshInterval || 15;

                console.log(`Setting up refresh every ${refreshMinutes} minutes`);

                setTimeout(() => {
                    console.log('Refreshing page...');
                    window.location.reload();
                }, refreshMinutes * 60 * 1000);
            }

            showError(message) {
                const slideContainer = document.getElementById('slideContainer');
                if (slideContainer) {
                    slideContainer.innerHTML = `
                        <div class="error-message">
                            <h2>‚ö†Ô∏è Display Error</h2>
                            <p>${message}</p>
                            <p class="retry-message">Retrying in 30 seconds...</p>
                        </div>
                    `;
                }

                // Retry after 30 seconds
                setTimeout(() => {
                    this.loadDeviceConfig();
                }, 30000);
            }
        }

        // Initialize digital signage when page loads
        console.log('DOM loaded, creating DigitalSignage instance...');
        let digitalSignageInstance = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded event fired');
            digitalSignageInstance = new DigitalSignage();
            
            // Store reference globally for cleanup
            window.opsignDisplay = digitalSignageInstance;
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (digitalSignageInstance) {
                digitalSignageInstance.cleanup();
            }
        });
    </script>
</body>
</html>
